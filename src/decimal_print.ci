
//static const char * base100_digit_no_leading_zeros_to_cstr[] = { 
static const char * digit_to_cstr__leading_zeroes__one[] = { 
   "0",  "1",  "2",  "3",  "4",  "5",  "6",  "7",  "8",  "9", 
  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", 
  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", 
  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", 
  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", 
  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", 
  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", 
  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", 
  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", 
  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99",  
  "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", 
  "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", 
  "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", 
  "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", 
  "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", 
  "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", 
  "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", 
  "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", 
  "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", 
  "190", "191", "192", "193", "194", "195", "196", "197", "198", "199",  
  "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", 
  "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", 
  "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", 
  "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", 
  "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", 
  "250", "251", "252", "253", "254", "255" 
}; 

//static const char * base100_digit_to_cstr[] = { 
static const char * digit_to_cstr__leading_zeroes__two[] = { 
  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", 
  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", 
  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", 
  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", 
  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", 
  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", 
  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", 
  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", 
  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", 
  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99",  
  "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", 
  "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", 
  "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", 
  "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", 
  "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", 
  "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", 
  "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", 
  "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", 
  "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", 
  "190", "191", "192", "193", "194", "195", "196", "197", "198", "199",  
  "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", 
  "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", 
  "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", 
  "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", 
  "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", 
  "250", "251", "252", "253", "254", "255" 
}; 

static const char * digit_to_cstr__leading_zeroes__three[] = { 
  "000", "001", "002", "003", "004", "005", "006", "007", "008", "009", 
  "010", "011", "012", "013", "014", "015", "016", "017", "018", "019", 
  "020", "021", "022", "023", "024", "025", "026", "027", "028", "029", 
  "030", "031", "032", "033", "034", "035", "036", "037", "038", "039", 
  "040", "041", "042", "043", "044", "045", "046", "047", "048", "049", 
  "050", "051", "052", "053", "054", "055", "056", "057", "058", "059", 
  "060", "061", "062", "063", "064", "065", "066", "067", "068", "069", 
  "070", "071", "072", "073", "074", "075", "076", "077", "078", "079", 
  "080", "081", "082", "083", "084", "085", "086", "087", "088", "089", 
  "090", "091", "092", "093", "094", "095", "096", "097", "098", "099",  
  "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", 
  "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", 
  "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", 
  "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", 
  "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", 
  "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", 
  "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", 
  "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", 
  "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", 
  "190", "191", "192", "193", "194", "195", "196", "197", "198", "199",  
  "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", 
  "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", 
  "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", 
  "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", 
  "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", 
  "250", "251", "252", "253", "254", "255" 
}; 

static const char * base100_digit_no_trailing_zeros_to_cstr[] = { 
   "", "01", "02", "03", "04", "05", "06", "07", "08", "09", 
  "1", "11", "12", "13", "14", "15", "16", "17", "18", "19", 
  "2", "21", "22", "23", "24", "25", "26", "27", "28", "29", 
  "3", "31", "32", "33", "34", "35", "36", "37", "38", "39", 
  "4", "41", "42", "43", "44", "45", "46", "47", "48", "49", 
  "5", "51", "52", "53", "54", "55", "56", "57", "58", "59", 
  "6", "61", "62", "63", "64", "65", "66", "67", "68", "69", 
  "7", "71", "72", "73", "74", "75", "76", "77", "78", "79", 
  "8", "81", "82", "83", "84", "85", "86", "87", "88", "89", 
  "9", "91", "92", "93", "94", "95", "96", "97", "98", "99",  
  "1" , "101", "102", "103", "104", "105", "106", "107", "108", "109", 
  "11", "111", "112", "113", "114", "115", "116", "117", "118", "119", 
  "12", "121", "122", "123", "124", "125", "126", "127", "128", "129", 
  "13", "131", "132", "133", "134", "135", "136", "137", "138", "139", 
  "14", "141", "142", "143", "144", "145", "146", "147", "148", "149", 
  "15", "151", "152", "153", "154", "155", "156", "157", "158", "159", 
  "16", "161", "162", "163", "164", "165", "166", "167", "168", "169", 
  "17", "171", "172", "173", "174", "175", "176", "177", "178", "179", 
  "18", "181", "182", "183", "184", "185", "186", "187", "188", "189", 
  "19", "191", "192", "193", "194", "195", "196", "197", "198", "199",  
  "2" , "201", "202", "203", "204", "205", "206", "207", "208", "209", 
  "21", "211", "212", "213", "214", "215", "216", "217", "218", "219", 
  "22", "221", "222", "223", "224", "225", "226", "227", "228", "229", 
  "23", "231", "232", "233", "234", "235", "236", "237", "238", "239", 
  "24", "241", "242", "243", "244", "245", "246", "247", "248", "249", 
  "25", "251", "252", "253", "254", "255" 
}; 


static const char * decimal_print__status_cstr(decimal_env_t * decimal_env, const uint8_t status) { 
  const char * status_cstr = NULL; 
  switch (status) { 
  case DECIMAL_STATUS__INVALID       : status_cstr = "INVALID"; break; 
  case DECIMAL_STATUS__ZERO          : status_cstr = "0"; break; 
  case DECIMAL_STATUS__INFINI        : status_cstr = "inf"; break; 
  case DECIMAL_STATUS__POS           : status_cstr = ""; break; 
  case DECIMAL_STATUS__NEG           : status_cstr = ""; break; 
  case DECIMAL_STATUS__POS_INFINI    : status_cstr = "+inf"; break; 
  case DECIMAL_STATUS__NEG_INFINI    : status_cstr = "-inf"; break; 
  case DECIMAL_STATUS__POS_EPSILON   : status_cstr = "+epsilon"; break; 
  case DECIMAL_STATUS__NEG_EPSILON   : status_cstr = "-epsilon"; break; 
  case DECIMAL_STATUS__DEVELOPPEMENT_LIMITE_NECESSAIRE: status_cstr = "DEVELOPPEMENT_LIMITE_NECESSAIRE"; break; 
#if 0 
  case DECIMAL_STATUS__0_DIV_BY_0    : status_cstr = "0_DIVIDED_BY_0"; break; 
  case DECIMAL_STATUS__INF_DIV_BY_INF: status_cstr = "INF_DIVIDE_BY_INF"; break; 
  case DECIMAL_STATUS__ZERO_BY_INF   : status_cstr = "ZERO_BY_INF"; break; 
  case DECIMAL_STATUS__INF_BY_ZERO   : status_cstr = "INF_BY_ZERO"; break; 
#endif 
  default: goto error_label__unlisted_status; 
  }; 
  return status_cstr; 

  error_label__unlisted_status: { 
    const char * cstr = decimal_status__cstr(status); 
    decimal_env -> error_id = DECIMAL__STATUS_NOT_LISTED_IN_SWITCH; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "Status not listed in switch: %d [%s]", ((int)status), cstr); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    //return decimal_env -> error_id; 
    return NULL; 
  }; 
}; 



int decimal__print_r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r) { 
  return decimal__print__base__int_and_float_separator_char__r(stduser_d, decimal_env, d_r, /*printing_base*/10, decimal_env -> print__int_and_float_separator_char); 
}; 

int decimal__print__base__int_and_float_separator_char__r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r, const uint8_t printing_base, const char separator) { 
  if (stduser_d <= 0) goto error_label__stduser_not_pos; 
  uint8_t error_digit; 
  const uint8_t status = (*d_r)[DECIMAL_STATUS_INDEX]; 
  //decimal_status__value_is_a_status_huh(const uint8_t status); 
  const char * status_cstr = decimal_print__status_cstr(decimal_env, status); 
  if (NULL == status_cstr) goto error_label__not_listed_status; 
  if ('\0' != *status_cstr) { 
    return write_string(stduser_d, status_cstr); 
  }; 

  decimal__conversion_matrix_from_internal_base_to_printing_base__compute(decimal_env, printing_base); 
  
  int printed_bytes_nb = 0; 
  int index = DECIMAL_FIXED_POINT_INDEX; //1 + DECIMAL_FIXED_POINT_SIZE; //DECIMAL_SIZE - 1; 
  for (;;) { 
    index++; 
    if (index > DECIMAL_DIGITS_INDEX_LAST) break; 
    if ((*d_r)[index] == DECIMAL_EOF_BYTE) break; 
  }; 
  for (;;) { 
    index--; 
    if (index <= DECIMAL_FIXED_POINT_INDEX) break; 
    if (0 == (*d_r)[index]) continue; 
    break; 
  }; 
  if (status == DECIMAL_STATUS__NEG) printed_bytes_nb += write(stduser_d, "-", 1); 
  
  // First digit — It should not have any leading zeroes. 
  { 
    const uint8_t digit = (*d_r)[index]; 
    if (digit >= DECIMAL_BASE) { error_digit = digit; goto error_label__malformed_number; } 
    //printed_bytes_nb += write_string(stduser_d, base100_digit_no_leading_zeros_to_cstr[digit]); 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[digit]); 
  }; 
  
  // Intermediate digits (not the first one, not the last one) 
  // until the location of the separator 
  // It should have both leading and trailing zeroes. 
  for (;;) { 
    index--; 
    if (index < DECIMAL_FIXED_POINT_INDEX) break; 
    const uint8_t digit = (*d_r)[index]; 
    if (digit >= DECIMAL_BASE) { error_digit = digit; goto error_label__malformed_number; }; 
    //printed_bytes_nb += write_string(stduser_d, base100_digit_to_cstr[digit]); 
#if (DECIMAL_BASE_MACRO <= 10) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[digit]); 
#elif (DECIMAL_BASE_MACRO <= 100) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__two[digit]); 
#else
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__three[digit]); 
#endif 
  }; 

  // Separator — Printing it if there is a digit. 
  assert(index == DECIMAL_FIXED_POINT_INDEX_MINUS1); 
  { 
    const uint8_t digit = (*d_r)[index]; 
    if (digit == DECIMAL_EOF_BYTE) goto label__exit; 
    //printed_bytes_nb += write(stduser_d, ".", 1); 
    printed_bytes_nb += write(stduser_d, &separator, 1); 
  }; 
  
  // Intermediate digits (not the first one, not the last one) 
  // after the location of the separator 
  // It should have both leading and trailing zeroes. 
  for (;;) { 
    if (index <= DECIMAL_DIGITS_INDEX_FIRST) break; 
    if ((*d_r)[index-1] == DECIMAL_EOF_BYTE) break; 
    const uint8_t digit = (*d_r)[index]; 
    assert(digit != DECIMAL_EOF_BYTE); 
    if (digit >= DECIMAL_BASE) { error_digit = digit; goto error_label__malformed_number; }; 
#if (DECIMAL_BASE_MACRO <= 10) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[digit]); 
#elif (DECIMAL_BASE_MACRO <= 100) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__two[digit]); 
#else
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__three[digit]); 
#endif 
    index--; 
  }; 

  // Last digit — It may or may not have trailing zeroes 
  assert(index >= DECIMAL_DIGITS_INDEX_FIRST); 
  assert(index <= DECIMAL_FIXED_POINT_INDEX_MINUS1); 
  { 
    const uint8_t digit = (*d_r)[index]; 
    assert(digit != DECIMAL_EOF_BYTE); 
    if (digit >= DECIMAL_BASE) { error_digit = digit; goto error_label__malformed_number; }; 
    printed_bytes_nb += write_string(stduser_d, base100_digit_no_trailing_zeros_to_cstr[digit]); 
  }; 
  
  goto label__exit; 

  assert(false); 

 label__exit: { 
    return printed_bytes_nb; 
  }; 
  
 error_label__malformed_number: { 
    decimal_env -> error_id = DECIMAL__MALFORMED_NUMBER; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "Malformed number: index = %d — char = %u", (int)index, ((unsigned int)error_digit)); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    printed_bytes_nb += write_string(stduser_d, "<malformed number>"); 
    return printed_bytes_nb; 
  }; 

 error_label__stduser_not_pos: { 
    decimal_env -> error_id = DECIMAL__STDUSER_NOT_POS; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "stduser_d is not positive: stduser_d = %d", (int)stduser_d); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    return -1; 
  }; 

  error_label__not_listed_status: { 
    return -1; 
  }; 
}; 


#if 0 
// OLD002
int decimal__print_r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r) { 
  return decimal__print__int_and_float_separator_char__r(stduser_d, decimal_env, d_r, decimal_env -> print__int_and_float_separator_char); 
}; 

int decimal__print__int_and_float_separator_char__r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r, const char separator) { 
  if (stduser_d <= 0) goto error_label__stduser_not_pos; 
  const uint8_t status = (*d_r)[DECIMAL_STATUS_INDEX]; 
  //decimal_status__value_is_a_status_huh(const uint8_t status); 
  const char * status_cstr = decimal_print__status_cstr(decimal_env, status); 
  if (NULL == status_cstr) goto error_label__not_listed_status; 
  if ('\0' != *status_cstr) { 
    return write_string(stduser_d, status_cstr); 
  }; 
  
  int printed_bytes_nb = 0; 
  int index = DECIMAL_FIXED_POINT_INDEX; //1 + DECIMAL_FIXED_POINT_SIZE; //DECIMAL_SIZE - 1; 
  for (;;) { 
    index++; 
    if (index > DECIMAL_DIGITS_INDEX_LAST) break; 
    if ((*d_r)[index] == DECIMAL_EOF_BYTE) break; 
  }; 
  for (;;) { 
    index--; 
    if (index <= DECIMAL_FIXED_POINT_INDEX) break; 
    if (0 == (*d_r)[index]) continue; 
    break; 
  }; 
  if (status == DECIMAL_STATUS__NEG) printed_bytes_nb += write(stduser_d, "-", 1); 
  
  // First digit — It should not have any leading zeroes. 
  { 
    const uint8_t digit = (*d_r)[index]; 
    if (digit >= DECIMAL_BASE) goto error_label__malformed_number; 
    //printed_bytes_nb += write_string(stduser_d, base100_digit_no_leading_zeros_to_cstr[digit]); 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[digit]); 
  }; 
  
  // Intermediate digits (not the first one, not the last one) 
  // until the location of the separator 
  // It should have both leading and trailing zeroes. 
  for (;;) { 
    index--; 
    if (index < DECIMAL_FIXED_POINT_INDEX) break; 
    const uint8_t digit = (*d_r)[index]; 
    if (digit >= DECIMAL_BASE) goto error_label__malformed_number; 
    //printed_bytes_nb += write_string(stduser_d, base100_digit_to_cstr[digit]); 
#if (DECIMAL_BASE_MACRO <= 10) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[digit]); 
#elif (DECIMAL_BASE_MACRO <= 100) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__two[digit]); 
#else
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__three[digit]); 
#endif 
  }; 

  // Separator — Printing it if there is a digit. 
  assert(index == DECIMAL_FIXED_POINT_INDEX_MINUS1); 
  { 
    const uint8_t digit = (*d_r)[index]; 
    if (digit == DECIMAL_EOF_BYTE) goto label__exit; 
    //printed_bytes_nb += write(stduser_d, ".", 1); 
    printed_bytes_nb += write(stduser_d, &separator, 1); 
  }; 
  
  // Intermediate digits (not the first one, not the last one) 
  // after the location of the separator 
  // It should have both leading and trailing zeroes. 
  for (;;) { 
    if (index <= DECIMAL_DIGITS_INDEX_FIRST) break; 
    if ((*d_r)[index-1] == DECIMAL_EOF_BYTE) break; 
    const uint8_t digit = (*d_r)[index]; 
    assert(digit != DECIMAL_EOF_BYTE); 
    if (digit >= DECIMAL_BASE) goto error_label__malformed_number; 
#if (DECIMAL_BASE_MACRO <= 10) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[digit]); 
#elif (DECIMAL_BASE_MACRO <= 100) 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__two[digit]); 
#else
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__three[digit]); 
#endif 
    index--; 
  }; 

  // Last digit — It may or may not have trailing zeroes 
  assert(index >= DECIMAL_DIGITS_INDEX_FIRST); 
  assert(index <= DECIMAL_FIXED_POINT_INDEX_MINUS1); 
  { 
    const uint8_t digit = (*d_r)[index]; 
    assert(digit != DECIMAL_EOF_BYTE); 
    if (digit >= DECIMAL_BASE) goto error_label__malformed_number; 
    printed_bytes_nb += write_string(stduser_d, base100_digit_no_trailing_zeros_to_cstr[digit]); 
  }; 
  
  goto label__exit; 

  assert(false); 

 label__exit: { 
    return printed_bytes_nb; 
  }; 
  
 error_label__malformed_number: { 
    decimal_env -> error_id = DECIMAL__MALFORMED_NUMBER; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "Malformed number: index = %d — char = %u", (int)index, ((unsigned int)c)); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    printed_bytes_nb += write_string(stduser_d, "<malformed number>"); 
    return printed_bytes_nb; 
  }; 

 error_label__stduser_not_pos: { 
    decimal_env -> error_id = DECIMAL__STDUSER_NOT_POS; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "stduser_d is not positive: stduser_d = %d", (int)stduser_d); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    return -1; 
  }; 

  error_label__not_listed_status: { 
    return -1; 
  }; 
}; 


#endif 

#if 0
int decimal__print_r__old001(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r) { 
  if (stduser_d <= 0) goto error_label__stduser_not_pos; 
  const uint8_t status = (*d_r)[DECIMAL_STATUS_INDEX]; 
  //decimal_status__value_is_a_status_huh(const uint8_t status); 
  const char * status_cstr = decimal_print__status_cstr(decimal_env, status); 
  if (NULL == status_cstr) goto error_label__not_listed_status; 
  if ('\0' != *status_cstr) { 
    return write_string(stduser_d, status_cstr); 
  }; 
  
  int printed_bytes_nb = 0; 
  int index = DECIMAL_FIXED_POINT_INDEX; //1 + DECIMAL_FIXED_POINT_SIZE; //DECIMAL_SIZE - 1; 
  for (;;) { 
    index++; 
    if (index == DECIMAL_SIZE) break; 
    if ((*d_r)[index] == DECIMAL_EOF_BYTE) break; 
  }; 
  index--; 
  if (status == DECIMAL_STATUS__NEG) printed_bytes_nb += write(stduser_d, "-", 1); 
  uint8_t c; 
  c = (*d_r)[index]; 
  if (c >= DECIMAL_BASE) goto error_label__malformed_number; 
  //printed_bytes_nb += write_string(stduser_d, base100_digit_no_leading_zeros_to_cstr[c]); 
  printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__one[c]); 
  for (;;) { 
    index--; 
    if (index < DECIMAL_FIXED_POINT_INDEX) break; 
    c = (*d_r)[index]; 
    if (c >= DECIMAL_BASE) goto error_label__malformed_number; 
    //printed_bytes_nb += write_string(stduser_d, base100_digit_to_cstr[c]); 
    printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__two[c]); 
  }; 
  
  c = (*d_r)[index]; 
  if (c == DECIMAL_EOF_BYTE) goto label__exit; 
  printed_bytes_nb += write(stduser_d, ".", 1); 
  for (;;) { 
    const char * * c_cstr_array; 
    if (index == DECIMAL_DIGITS_INDEX) { 
      c_cstr_array = base100_digit_no_trailing_zeros_to_cstr; 
      //printed_bytes_nb += write_string(stduser_d, base100_digit_no_trailing_zeros_to_cstr[c]); 
    } 
    else if ((*d_r)[index-1] == DECIMAL_EOF_BYTE) { 
      c_cstr_array = base100_digit_no_trailing_zeros_to_cstr; 
      //printed_bytes_nb += write_string(stduser_d, base100_digit_no_trailing_zeros_to_cstr[c]); 
    }
    else { 
      c_cstr_array = base100_digit_to_cstr; 
      //printed_bytes_nb += write_string(stduser_d, base100_digit_to_cstr[c]); 
    }; 
    const char * c_cstr = c_cstr_array[c]; 
    printed_bytes_nb += write_string(stduser_d, c_cstr); 
    index--; 
    if (index < DECIMAL_DIGITS_INDEX) break;  
    c = (*d_r)[index]; 
    if (c == DECIMAL_EOF_BYTE) return DECIMAL__OK; 
    if (c >= DECIMAL_BASE) goto error_label__malformed_number; 
  }; 
  
  goto label__exit; 

  assert(false); 

 label__exit: { 
    return printed_bytes_nb; 
  }; 
  
 error_label__malformed_number: { 
    decimal_env -> error_id = DECIMAL__MALFORMED_NUMBER; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "Malformed number: index = %d — char = %u", (int)index, ((unsigned int)c)); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    printed_bytes_nb += write_string(stduser_d, "<malformed number>"); 
    return printed_bytes_nb; 
  }; 

 error_label__stduser_not_pos: { 
    decimal_env -> error_id = DECIMAL__STDUSER_NOT_POS; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "stduser_d is not positive: stduser_d = %d", (int)stduser_d); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    return -1; 
  }; 

  error_label__not_listed_status: { 
    return -1; 
  }; 
}; 


#endif 

int decimal__print_ln_r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r) { 
  const int printed_bytes_nb = decimal__print_r(stduser_d, decimal_env, d_r); 
  if (-1 == printed_bytes_nb) return -1; 
  write_eol(stduser_d); 
  return 1 + printed_bytes_nb; 
}; 



static int decimal__print_debug_r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r) { 
  if (stduser_d <= 0) goto error_label__stduser_not_pos; 
  const uint8_t status = (*d_r)[DECIMAL_STATUS_INDEX]; 
  const char *  status_cstr = decimal_print__status_cstr(decimal_env, status); 
  if (NULL == status_cstr) goto error_label__not_listed_status; 
  if ('\0' != *status_cstr) { 
    return write_string(stduser_d, status_cstr); 
  }; 
  
  int printed_bytes_nb = 0; 
  
  if (status == DECIMAL_STATUS__NEG) printed_bytes_nb += write(stduser_d, "-", 1); 
  
  int index = DECIMAL_SIZE; 
  for (;;) { 
    index--; 
    if (DECIMAL_DIGITS_INDEX > index) break; 
    if ((*d_r)[index] != DECIMAL_EOF_BYTE) break; 
  }; 
  
  if (DECIMAL_DIGITS_INDEX > index) { 
    printed_bytes_nb += write_string(stduser_d, "<empty>"); 
    goto label__exit; 
  }; 
  
  { 
    for (;;) { 
      const uint8_t c = (*d_r)[index]; 
      if (c == DECIMAL_EOF_BYTE) break; 
      if (c >= 100) { printed_bytes_nb += write_string(stduser_d, "<"); printed_bytes_nb += dputn(stduser_d, c); printed_bytes_nb += write_string(stduser_d, ">"); }  
      //else { printed_bytes_nb += write_string(stduser_d, base100_digit_to_cstr[c]); }; 
      else { printed_bytes_nb += write_string(stduser_d, digit_to_cstr__leading_zeroes__two[c]); }; 
      index--; 
      if (DECIMAL_DIGITS_INDEX > index) break; 
    }; 
    index++; 
    //{ write_string(stduser_d, "["); dputn(stduser_d, index - DECIMAL_FIXED_POINT_SIZE); write_string(stduser_d, "]"); }; 
    { printed_bytes_nb += write_string(stduser_d, "["); printed_bytes_nb += dputn(stduser_d, index); printed_bytes_nb += write_string(stduser_d, "]"); }; 
    goto label__exit; 
  }; 

  assert(false); 

 label__exit: { 
    return printed_bytes_nb; 
  }; 

 error_label__malformed_number: { 
    decimal_env -> error_id = DECIMAL__MALFORMED_NUMBER; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "Malformed number: index = %d — char = %u", (int)index, ((unsigned int)(*d_r)[index])); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    printed_bytes_nb += write_string(stduser_d, "<malformed number>"); 
    return printed_bytes_nb; 
  }; 

 error_label__stduser_not_pos: { 
    decimal_env -> error_id = DECIMAL__STDUSER_NOT_POS; 
    snprintf(decimal_env -> error_str, DECIMAL_ENV__ERROR_BUFFER_SIZE, "stduser_d is not positive: stduser_d = %d", (int)stduser_d); 
    if (decimal_env -> stdlog_d > 0) { dprintf(decimal_env -> stdlog_d, "{" __FILE__ ":" STRINGIFY(__LINE__) ":<%s()>}: Error: " "%s" "\n", __func__, decimal_env -> error_str); }; 
    return -1; 
  }; 

  error_label__not_listed_status: { 
    return -1; 
  }; 
}; 

int decimal__print_debug_ln_r(const int stduser_d, decimal_env_t * decimal_env, const decimal_t * d_r) { 
  const int printed_bytes_nb = decimal__print_debug_r(stduser_d, decimal_env, d_r); 
  if (-1 == printed_bytes_nb) return -1; 
  write_eol(stduser_d); 
  return 1 + printed_bytes_nb; 
}; 



