#ifndef DECIMAL_TOKEN_TYPE_H
#define DECIMAL_TOKEN_TYPE_H

// RL: All those tokens should be ordered by priorities: 
//     the lowest priority first, the highest priority last. 
enum { 
  DECIMAL_TOKEN_NULL, // It's the invalid token. 
  DECIMAL_TOKEN_EOF, 
  // RL: Syntatic sugar // Very low priority, i.e. outmost nodes  
  DECIMAL_TOKEN_OF, 
  DECIMAL_TOKEN_TO, 
  DECIMAL_TOKEN_DOWNTO, 
  DECIMAL_TOKEN_STEP, 
  DECIMAL_TOKEN_PTVIRG, 
  DECIMAL_TOKEN_OPENPAR, 
  DECIMAL_TOKEN_CLOSEPAR, 
  DECIMAL_TOKEN_OPENBRACKET, 
  DECIMAL_TOKEN_CLOSEBRACKET, 
  DECIMAL_TOKEN_OPENBRACE, 
  DECIMAL_TOKEN_CLOSEBRACE, 
  DECIMAL_TOKEN_DEUXPOINTS, 
  DECIMAL_TOKEN_VIRGULE, 
  DECIMAL_TOKEN_AS, 
  DECIMAL_TOKEN_HUH, 
  // RL: EXPR 
  DECIMAL_TOKEN_AFFECTATION, 
  DECIMAL_TOKEN_AFFECTATION_SIMPLE, 
  DECIMAL_TOKEN_AFFECTATION_IADD, 
  DECIMAL_TOKEN_AFFECTATION_RADD, 
  DECIMAL_TOKEN_AFFECTATION_ISUB, 
  DECIMAL_TOKEN_AFFECTATION_RSUB, 
  DECIMAL_TOKEN_AFFECTATION_IMULT, 
  DECIMAL_TOKEN_AFFECTATION_RMULT, 
  DECIMAL_TOKEN_AFFECTATION_IDIV, 
  DECIMAL_TOKEN_AFFECTATION_RDIV, 
  DECIMAL_TOKEN_AFFECTATION_IMOD, 
  DECIMAL_TOKEN_AFFECTATION_L_AND, 
  DECIMAL_TOKEN_AFFECTATION_L_OR, 
  DECIMAL_TOKEN_AFFECTATION_L_XOR, 
  DECIMAL_TOKEN_AFFECTATION_L_NOT, 
  DECIMAL_TOKEN_AFFECTATION_B_AND, 
  DECIMAL_TOKEN_AFFECTATION_B_OR, 
  DECIMAL_TOKEN_AFFECTATION_B_XOR, 
  DECIMAL_TOKEN_AFFECTATION_B_NOT, 
  DECIMAL_TOKEN_AFFECTATION_B_RSHIFT, 
  DECIMAL_TOKEN_AFFECTATION_B_LSHIFT, 
  DECIMAL_TOKEN_LOGICAL_AND, 
  DECIMAL_TOKEN_LOGICAL_OR, 
  DECIMAL_TOKEN_LOGICAL_XOR, // RL: BITWISE_XOR is definitely different. 
  DECIMAL_TOKEN_LOGICAL_NOT, 
  DECIMAL_TOKEN_EQUAL, // RL: The question is the interpretation of "a == b and d != e". 
  DECIMAL_TOKEN_DIFF, 
  DECIMAL_TOKEN_INF, // RL: The question is the interpretation of "a < b and d >= e". 
  DECIMAL_TOKEN_SUP, 
  DECIMAL_TOKEN_INFEQ, 
  DECIMAL_TOKEN_SUPEQ, 
  DECIMAL_TOKEN_IDIV, // RL: This thing has definitely a low priority: "1 + 2 div 4 + 3" 
  DECIMAL_TOKEN_IMOD, 
  DECIMAL_TOKEN_BITWISE_AND, 
  DECIMAL_TOKEN_BITWISE_OR, 
  DECIMAL_TOKEN_BITWISE_XOR, // RL: BOOL_XOR is definitely different. 
  DECIMAL_TOKEN_BITWISE_NOT, 
  DECIMAL_TOKEN_BITWISE_SHIFT_LEFT, 
  DECIMAL_TOKEN_BITWISE_SHIFT_RIGHT, 
  DECIMAL_TOKEN_IPLUS, 
  DECIMAL_TOKEN_RPLUS, 
  DECIMAL_TOKEN_IMOINS, 
  DECIMAL_TOKEN_RMOINS, 
  DECIMAL_TOKEN_IMULT, 
  DECIMAL_TOKEN_RMULT, 
  DECIMAL_TOKEN_RDIV, 
  DECIMAL_TOKEN_POINT, 
  DECIMAL_TOKEN_FLECHE, 
  DECIMAL_TOKEN_PTR, 
  DECIMAL_TOKEN_REF, 
  DECIMAL_TOKEN_IPLUS_UNAIRE, 
  DECIMAL_TOKEN_RPLUS_UNAIRE, 
  DECIMAL_TOKEN_IMOINS_UNAIRE, 
  DECIMAL_TOKEN_RMOINS_UNAIRE, 
  DECIMAL_TOKEN_INC, 
  DECIMAL_TOKEN_DEC, 
  // RL: Constant values, which have the upmost priorities 
  DECIMAL_TOKEN_TRUE, 
  DECIMAL_TOKEN_FALSE, 
  DECIMAL_TOKEN_ENTIER, 
  DECIMAL_TOKEN_REEL__VIRG, 
  DECIMAL_TOKEN_REEL__DOT, 
  DECIMAL_TOKEN_REEL__E, 
  DECIMAL_TOKEN_STRING_C, 
  DECIMAL_TOKEN_STRING_C__EOL, 
  DECIMAL_TOKEN_STRING_C__EOF, 
  DECIMAL_TOKEN_STRING_P, 
  DECIMAL_TOKEN_STRING_P__EOL, 
  DECIMAL_TOKEN_STRING_P__EOF, 
  DECIMAL_TOKEN_NIL, 
  DECIMAL_TOKEN_NULL_PTR, 
  // RL: LL(1) type 
  DECIMAL_TOKEN_TYPE, 
  DECIMAL_TOKEN_TYPE_ALIAS, 
  DECIMAL_TOKEN_BOOLEAN, 
  DECIMAL_TOKEN_INTEGER, 
  DECIMAL_TOKEN_FLOAT, 
  DECIMAL_TOKEN_STRING, 
  DECIMAL_TOKEN_SUBRANGE, 
  DECIMAL_TOKEN_ARRAY, 
  DECIMAL_TOKEN_RECORD, 
  DECIMAL_TOKEN_VARIANT, 
  // RL: LL(1) control flow 
  DECIMAL_TOKEN_IF, 
  DECIMAL_TOKEN_WHEN, 
  DECIMAL_TOKEN_UNLESS, 
  DECIMAL_TOKEN_WHILE, 
  DECIMAL_TOKEN_FOR, 
  DECIMAL_TOKEN_REPEAT, 
  DECIMAL_TOKEN_BEGIN, 
  DECIMAL_TOKEN_PROCEDURE, 
  DECIMAL_TOKEN_FONCTION, 
  DECIMAL_TOKEN_METHODE, 
  DECIMAL_TOKEN_LAMBDA, 
  DECIMAL_TOKEN_CONST, 
  DECIMAL_TOKEN_VAR, 
  //DECIMAL_TOKEN_REC, // RL: Needless. 'This' is not a token as well. 
  // RL: control flow others 
  DECIMAL_TOKEN_DONE, 
  DECIMAL_TOKEN_DO, 
  DECIMAL_TOKEN_THEN, 
  DECIMAL_TOKEN_ELSE, 
  DECIMAL_TOKEN_FI, 
  DECIMAL_TOKEN_UNTIL, 
  DECIMAL_TOKEN_END, 
  // RL: Other qualifying keywords 
  DECIMAL_TOKEN_BYREF, 
  DECIMAL_TOKEN_BYVAL, 
  // RL: Ident 
  DECIMAL_TOKEN_SYNTAX_MASTER, 
  DECIMAL_TOKEN_SYNTAX_KEYWORD, // RL: Could be handled like a regular ident by the parser? 
  DECIMAL_TOKEN_IDENT, 
  // RL: Ignored tokens 
  DECIMAL_TOKEN_EOL, 
  DECIMAL_TOKEN_BLANC, 
  DECIMAL_TOKEN_COMMENT__ONE_LINE_CPP, 
  DECIMAL_TOKEN_COMMENT__ONE_LINE_SCRIPT, 
  DECIMAL_TOKEN_COMMENT__MULTI_LINES_C_STYLE, 
  DECIMAL_TOKEN_COMMENT__MULTI_LINES_C_STYLE__EOF, 
  DECIMAL_TOKEN_COMMENT__MULTI_LINES_C_STYLE__LONELY_ENDING, 
  DECIMAL_TOKEN_TYPE_COUNT  
}; 

enum { DECIMAL_TOKEN__SYNTAX_MASTER__BASE  = DECIMAL_TOKEN_TYPE_COUNT }; 
enum { DECIMAL_TOKEN__SYNTAX_MASTER__SIZE  = 16 }; 
enum { DECIMAL_TOKEN__SYNTAX_MASTER__TOP   = DECIMAL_TOKEN__SYNTAX_MASTER__BASE + DECIMAL_TOKEN__SYNTAX_MASTER__SIZE }; 

enum { DECIMAL_TOKEN__SYNTAX_KEYWORD__BASE = DECIMAL_TOKEN__SYNTAX_MASTER__TOP }; 
enum { DECIMAL_TOKEN__SYNTAX_KEYWORD__SIZE = 16 }; 
enum { DECIMAL_TOKEN__SYNTAX_KEYWORD__TOP  = DECIMAL_TOKEN__SYNTAX_KEYWORD__BASE + DECIMAL_TOKEN__SYNTAX_KEYWORD__SIZE }; 

//#define TOKEN_MAX DECIMAL_TOKEN_COUNT 
enum { TOKEN_MAX = DECIMAL_TOKEN__SYNTAX_KEYWORD__TOP }; 



 
// RL: Token aliases. 
enum { 
  DECIMAL_TOKEN_TYPE_INVALID  = DECIMAL_TOKEN_NULL, 
  DECIMAL_TOKEN_ASSIGN        = DECIMAL_TOKEN_AFFECTATION, 
  DECIMAL_TOKEN_METHOD        = DECIMAL_TOKEN_METHODE, 
  DECIMAL_TOKEN_COMMA         = DECIMAL_TOKEN_VIRGULE, 
  DECIMAL_TOKEN_COLON         = DECIMAL_TOKEN_DEUXPOINTS, 
  DECIMAL_TOKEN_SEMICOLON     = DECIMAL_TOKEN_PTVIRG, 
  DECIMAL_TOKEN_POINTVIRGULE  = DECIMAL_TOKEN_PTVIRG, 
  DECIMAL_TOKEN_POINT_VIRGULE = DECIMAL_TOKEN_PTVIRG, 
  DECIMAL_TOKEN_FUNCTION      = DECIMAL_TOKEN_FONCTION, 
  DECIMAL_TOKEN_IMINUS        = DECIMAL_TOKEN_IMOINS, 
  DECIMAL_TOKEN_RMINUS        = DECIMAL_TOKEN_RMOINS, 
  DECIMAL_TOKEN_DOT           = DECIMAL_TOKEN_POINT, 
  DECIMAL_TOKEN_ARROW         = DECIMAL_TOKEN_FLECHE, 
  DECIMAL_TOKEN_CHAINE_C      = DECIMAL_TOKEN_STRING_C, 
  DECIMAL_TOKEN_CHAINE_P      = DECIMAL_TOKEN_STRING_P, 
  DECIMAL_TOKEN_REAL          = DECIMAL_TOKEN_FLOAT, 
}; 

typedef       uint8_t                 int_decimal_token_type_t; 
extern  const int_decimal_token_type_t  int_decimal_token_type_max; // RL: Use for storage, where data should be packed. Anywhere else, 'int' is good. The property ensures that a token_type will fit into a 'int_decimal_token_type_t'. 

extern const int_decimal_token_type_t decimal_token_type_count; 

extern const char * decimal_token__type_get_cstr(const int_decimal_token_type_t token_type); 
#define decimal_token__type_cstr decimal_token__type_get_cstr



#endif /* DECIMAL_TOKEN_TYPE_H */

